// Copyright 2022 The gRPC Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package grpc.observability.logging.v1;

import "google/protobuf/duration.proto";

option java_package = "io.grpc.observability.logging";
option java_multiple_files = true;
option java_outer_classname = "ObservabilityLoggingProto";
option go_package = "google.golang.org/grpc/gcp/observability/internal/logging";

// Still in same package, so no complications there
// binaryLog proto (->) old payload
//                  (->) <- (how does that affect conversion (what Eric wrote about)  1. (functionally, how did the payloads differ, Eric talks about conversion from binary logging, not the diff between these two)
// binaryLog proto (->) new payload


message Payload { // inline this, delete others, replaces metadata
    /* Previous:
    // Used by header event or trailer event
    Metadata metadata = 15;

    // A list of metadata pairs
    message Metadata {
        repeated MetadataEntry entry = 1;
    }

    // One metadata key value pair
    message MetadataEntry {
        string key = 1;
        bytes value = 2;
    }
    */
    // now - map<string, string> metadata = 1; "inline the repeated Metadata entry" is this the same?
    // I think it's same iteration of key values but populates a map? rather than a list of {key, values}, value switched from []byte -> string, need to encode by (string -> []byte -> Base64)?
    map<string, string> metadata = 1; // are the values v1, v2, v3, v4 or individual?

    // the RPC timeout value - Eric mentioned this duration will be a headache.
    google.protobuf.Duration timeout = 2;
    // The gRPC status code
    uint32 status_code = 3;

    // The gRPC status message
    string status_message = 4;

    // The value of the grpc-status-details-bin metadata key, if any.
    // This is always an encoded google.rpc.Status message
    bytes status_details = 5;

    uint32 message_length = 6; // messageLength
    // Used by message event
    bytes message = 7;
}

// gRPC changes in regards to global dial and server options

// global dial and server options -> separate PR
// Then the new filtering logic.


// metrics code change one liner

// Eric's schema changes. also parallel, but built on top

// make this partitioned to get better estimate and timeline and show
// progress.

// DO GRAD CHECKIN, get my package, do laundry, swim
message GrpcLogRecord {
    // List of event types
    enum EventType {
        // Unknown event type
        NONE = 0;
        // Header sent from client to server
        CLIENT_HEADER = 1;
        // Header sent from server to client
        SERVER_HEADER = 2;
        // Message sent from client to server
        CLIENT_MESSAGE = 3;
        // Message sent from server to client
        SERVER_MESSAGE = 4;
        // A signal that client is done sending
        CLIENT_HALF_CLOSE = 5;
        // Trailer indicates the end of the gRPC call
        SERVER_TRAILER = 6;
        // A signal that the rpc is canceled
        CANCEL = 7;
    }
    // The entity that generates the log entry
    enum Logger {
        UNKNOWN = 0; // Don't do this inline - even if Doug makes you switch, this makes it so much cleaner as an intermediate step
        CLIENT = 1;
        SERVER = 2;
    }
    // The log severity level of the log entry
    enum LogLevel {
        LOG_LEVEL_UNKNOWN = 0;
        LOG_LEVEL_TRACE = 1;
        LOG_LEVEL_DEBUG = 2;
        LOG_LEVEL_INFO = 3;
        LOG_LEVEL_WARN = 4;
        LOG_LEVEL_ERROR = 5;
        LOG_LEVEL_CRITICAL = 6;
    }

    // Uniquely identifies a call. The value must not be 0 in order to disambiguate
    // from an unset value.
    // Each call may have several log entries. They will all have the same rpc_id.
    // Nothing is guaranteed about their value other than they are unique across
    // different RPCs in the same gRPC process.

    // I switched this from RPC_ID. Is this the same? I think so
    string call_id = 2; // callId in JSON
    // The entry sequence ID for this call. The first message has a value of 1,
    // to disambiguate from an unset value. The purpose of this field is to
    // detect missing entries in environments where durability or ordering is
    // not guaranteed.
    uint64 sequence_id = 3; // sequenceId

    EventType event_type = 4;      // one of the above EventType enum
    Logger event_logger = 5;  // one of the above EventLogger enum

    Payload payload = 6;
    // true if message or metadata field is either truncated or omitted due
    // to config options
    bool payload_truncated = 7; // payloadTruncated

    // Peer address information. On client side, peer is logged on server
    // header event or trailer event (if trailer-only). On server side, peer
    // is always logged on the client header event.
    Address peer = 8;

    // A single process may be used to run multiple virtual servers with
    // different identities.
    // The authority is the name of such a server identify. It is typically a
    // portion of the URI in the form of <host> or <host>:<port>.
    string authority = 10;

    // the name of the service
    string service_name = 11; // serviceName
    // the name of the RPC method
    string method_name = 12; // methodName

    // Size of the message or metadata, depending on the event type,
    // regardless of whether the full message or metadata is being logged
    // (i.e. could be truncated or omitted).
    uint32 payload_size = 13;


    // A list of metadata pairs
    message Metadata {
        repeated MetadataEntry entry = 1;
    }

    // One metadata key value pair
    message MetadataEntry {
        string key = 1;
        bytes value = 2;
    }

    // Address information
    message Address {
        enum Type {
            TYPE_UNKNOWN = 0;
            TYPE_IPV4 = 1;  // in 1.2.3.4 form
            TYPE_IPV6 = 2;  // IPv6 canonical form (RFC5952 section 4)
            TYPE_UNIX = 3;  // UDS string
        }
        Type type = 1;
        string address = 2;
        // only for TYPE_IPV4 and TYPE_IPV6
        uint32 ip_port = 3;
    }
}
